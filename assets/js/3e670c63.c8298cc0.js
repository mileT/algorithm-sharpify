(self.webpackChunkleetcode_notes_doc=self.webpackChunkleetcode_notes_doc||[]).push([[6859],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return p},kt:function(){return g}});var s=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);n&&(s=s.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,s)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,s,r=function(e,n){if(null==e)return{};var t,s,r={},i=Object.keys(e);for(s=0;s<i.length;s++)t=i[s],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(s=0;s<i.length;s++)t=i[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=s.createContext({}),l=function(e){var n=s.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=l(e.components);return s.createElement(o.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return s.createElement(s.Fragment,{},n)}},d=s.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,p=u(e,["components","mdxType","originalType","parentName"]),d=l(t),g=r,m=d["".concat(o,".").concat(g)]||d[g]||c[g]||i;return t?s.createElement(m,a(a({ref:n},p),{},{components:t})):s.createElement(m,a({ref:n},p))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,a=new Array(i);a[0]=d;var u={};for(var o in n)hasOwnProperty.call(n,o)&&(u[o]=n[o]);u.originalType=e,u.mdxType="string"==typeof e?e:r,a[1]=u;for(var l=2;l<i;l++)a[l]=t[l];return s.createElement.apply(null,a)}return s.createElement.apply(null,t)}d.displayName="MDXCreateElement"},1898:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return a},metadata:function(){return u},toc:function(){return o},default:function(){return p}});var s=t(2122),r=t(9756),i=(t(7294),t(3905)),a={sidebar_label:"Recommend Bussiness Yelp OA",sidebar_position:76},u={unversionedId:"blind-curated-75/recommend businesses yelp oa1",id:"blind-curated-75/recommend businesses yelp oa1",isDocsHomePage:!1,title:"Question",description:"Yelp can recommend businesses based on a distance you're willing to travel.",source:"@site/docs/blind-curated-75/recommend businesses yelp oa1.md",sourceDirName:"blind-curated-75",slug:"/blind-curated-75/recommend businesses yelp oa1",permalink:"/algorithm-sharpify/docs/blind-curated-75/recommend businesses yelp oa1",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/blind-curated-75/recommend businesses yelp oa1.md",version:"current",sidebar_label:"Recommend Bussiness Yelp OA",sidebarPosition:76,frontMatter:{sidebar_label:"Recommend Bussiness Yelp OA",sidebar_position:76},sidebar:"tutorialSidebar",previous:{title:"371. Sum of Two Integers",permalink:"/algorithm-sharpify/docs/blind-curated-75/70 sum of two integers"},next:{title:"Docusaurus Intro",permalink:"/algorithm-sharpify/docs/intro"}},o=[{value:"Args:",id:"args",children:[]},{value:"Output:",id:"output",children:[]}],l={toc:o};function p(e){var n=e.components,t=(0,r.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,s.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Yelp can recommend businesses based on a distance you're willing to travel."),(0,i.kt)("p",null,"Given a distance input and a connected acyclic graph of businesses with edges as distances, return the list of names of businesses within the distance input."),(0,i.kt)("h3",{id:"args"},"Args:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"starting business: a Business object to start from"),(0,i.kt)("li",{parentName:"ul"},"distance: int")),(0,i.kt)("h3",{id:"output"},"Output:"),(0,i.kt)("p",null,"list of str: A list of Business names that are within the given distance of the starting Business"),(0,i.kt)("p",null,"Distance is inclusive, meaning if a business is 5 away, then a distance input of 5 means that business IS reachable."),(0,i.kt)("p",null,"The return value should NOT have the name of the starting business. Therefore, if no businesses are within the given distance, return an empty list."),(0,i.kt)("p",null,"The return value is NOT required to be sorted."),(0,i.kt)("h1",{id:"solution"},"Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Business {\n    String name;\n    Map<Business, Integer> nearbyBusinesses = new HashMap<>();\n    public String getName() {\n        return this.name;\n    }\n    public Map<Business, Integer> getNearbyBusinesses() {\n        return this.nearbyBusinesses;\n    }\n}\nclass Solution {\n    public static List<String> findReachableBusinesses(Business startingBusiness, int distance) {\n        List<String> result = new ArrayList<>();\n        Map<Business, Boolean> visited = new HashMap<>();\n        visited.put(startingBusiness, true);\n        dfs(startingBusiness, result, visited, distance, 0);\n        return result;\n    }\n\n    private void bfs(Business start, List<String> result, Map<Business, Boolean> visited, int distance, int current) {\n        Map<Business, Integer> neighbors = start.getNearbyBusiness();\n        for(Business b : neighbors.keySet()) {\n            if(visited.getOrDefault(b, false) == false && neighbors.get(b) + current <= distance) {\n                visited.put(b, true);\n                result.add(b.getName());\n                dfs(b, result, distance, current + neighbor.get(b));\n            }\n        }\n    }\n\n    public static List<String> findReachableBusinesses(Business startingBusiness, int distance) {\n        Map<String, Integer> businessNameDistanceMap = new HashMap<>();\n        Queue<Business> queue = new ArrayList<>();\n        queue.add(startingBusiness);\n        while(!queue.isEmpty()) {\n            Business temp = queue.poll();\n            int previousDistance = 0;\n            if(businessNameDistanceMap.get(temp.getName()) != null){\n                previouDistance = businessNameDistanceMap.get(temp.getName();\n            }\n            for(Map.Entry<Business, Integer> item: temp.getNearbyBusiness().entrySet()) {\n                if(previousDistance + item.getValue() <= distance) {\n                    businessNameDistanceMap.put(item.getKey().getName(), item.getValue());\n                    queue.add(item.getKey());\n                }\n            }\n        }\n        return new ArrayList(businessNameDistanceMap.keySet());\n    }\n}\n")),(0,i.kt)("p",null,"HashMap & PriorityQueue "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public List<String> topKFrequent(String[] words, int k) {\n        List<String> result = new LinkedList<>();\n        Map<String, Integer> map = new HashMap<>();\n        for(String word : words) {\n            map.put(s. map.getOrDefault(s, 0) + 1);\n        }\n\n        PriorityQueue<Map.Entry<String, Integer>> maxHeap = new PrinorityQueue<>(k, (a, b) -> a.getValue() == b.getValue() ? a.getKey().compareTo(b.getValue()) : b.getValue() - a.getValue());\n\n        for(Map.Entry<String, Integer> entry : map.entrySet()) {\n            maxHeap.add(entry);\n        }\n\n        while(result.size() < k) {\n            result.add(maxHeap.poll().getKey());\n        }\n        return result;\n    }\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public List<String> topKFrequent(String[] words, int k) {\n        \n        List<String> result = new LinkedList<>();\n        Map<String, Integer> map = new HashMap<>();\n        for(int i=0; i<words.length; i++)\n        {\n            if(map.containsKey(words[i]))\n                map.put(words[i], map.get(words[i])+1);\n            else\n                map.put(words[i], 1);\n        }\n        \n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(\n                 (a,b) -> a.getValue()==b.getValue() ? b.getKey().compareTo(a.getKey()) : a.getValue()-b.getValue()\n        );\n        \n        for(Map.Entry<String, Integer> entry: map.entrySet())\n        {\n            pq.offer(entry);\n            if(pq.size()>k)\n                pq.poll();\n        }\n\n        while(!pq.isEmpty())\n            result.add(0, pq.poll().getKey());\n        \n        return result;\n    }\n}\n")))}p.isMDXComponent=!0}}]);